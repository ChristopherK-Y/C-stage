/*
在一个「平衡字符串」中，'L' 和 'R' 字符的数量是相同的。
给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。
返回可以通过分割得到的平衡字符串的最大数量。

示例 1：
输入：s = "RLRRLLRLRL"
输出：4
解释：s 可以分割为 "RL", "RRLL", "RL", "RL", 每个子字符串中都包含相同数量的 'L' 和 'R'。

示例 2：
输入：s = "RLLLLRRRLR"
输出：3
解释：s 可以分割为 "RL", "LLLRRR", "LR", 每个子字符串中都包含相同数量的 'L' 和 'R'。

示例 3：
输入：s = "LLLLRRRR"
输出：1
解释：s 只能保持原样 "LLLLRRRR".
 
提示：
1 <= s.length <= 1000
s[i] = 'L' 或 'R'
分割得到的每个字符串都必须是平衡字符串。
*/

#include"public.h"//头文件

/**
* 此函数不是这个题目的正确解法，此方法是把平衡字符串当成一定是对称的字符串
* （例如上面所讲的三个例子），正确地方法看下面地函数
* 功能：将平衡字符串S分割成尽可能多的平衡字符串，返回子串的最大数量。
* 返回值：int最大的字串数目
* 参数：字符串指针（char*）
* 
* 思路：
* ①首先定义一个字符指针ptr，令其指向字符串的第二元素
* ②定义一个计数器count，用于记录符合要求得子串数量
* ③进入while循环，如果当前指针或者当前指针指向的元素得前一个元素是0（'\0'）那么循环就截止了
* 分支①：如果当前指针所指的的元素和它的前一个元素不相等，那么count++，指针向后移动2个位置（因为，已经元素已经不同了，就没有必要在和当前元素进行对比了）
* 分支②：否则，指针后移
* ④直到，不符合while循环，返回count计数器的值
*/
int balancedStringSplit_mine(char* s) {
	char* ptr = s + 1;
	int count = 0;
	while (*ptr && *(ptr - 1)) {
		if (*ptr != *(ptr - 1)) {
			count++;
			ptr += 2;
		}
		else {
			ptr++;
		}
	}
	return count;
}



/**
* 正确的解法->
* 功能：将平衡字符串S分割成尽可能多的平衡字符串，返回子串的最大数量。
* 返回值：int：最大的字串数目
* 参数：字符串指针（char*）
* 
* 思路：
* ①首先，我们好好的先了解一下什么是平衡字符串
* 在一个「平衡字符串」中，'L' 和 'R' 字符的数量是相同的，这里只是提到了数量相等，没有提及它的顺序
* 所以,"RRRLLRLL"这个子字符串，它是一个符合要求的平衡字符串
* ②所以，思路就是：
* 
* ①我们先定义一个指向字符串的指针ptr、一个计算符合要求的子字符串的个数count
* 一个nums，如果遇到'L'就加1，否则遇到'R'就减1
* ②我们现在应该可以很简单的理解到它的思想所在，一旦nums现在等于0了，
* 就说明有一个符合要求的平衡子字符串了，那么，count++
* ③最后返回count就可以了
*/
int balancedStringSplit(char* s) {
	char* ptr = s;
	int count = 0;
	int nums = 0;
	while (*ptr) {
		if (*ptr == 'L') {
			nums++;
		}
		else {
			nums--;
		}
		if (nums == 0) {
			count++;
		}
		ptr++;
	}
	return count;
}


//int main() {//测试代码块
//	const char* str = "RLRRRLLRLL";
//					   
//	printf("%d", balancedStringSplit(str));
//	return 0;
//}